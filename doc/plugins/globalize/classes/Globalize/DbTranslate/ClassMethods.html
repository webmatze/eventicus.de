<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html 
     PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
     "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <title>Module: Globalize::DbTranslate::ClassMethods</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta http-equiv="Content-Script-Type" content="text/javascript" />
  <link rel="stylesheet" href="../../.././rdoc-style.css" type="text/css" media="screen" />
  <script type="text/javascript">
  // <![CDATA[

  function popupCode( url ) {
    window.open(url, "Code", "resizable=yes,scrollbars=yes,toolbar=no,status=no,height=150,width=400")
  }

  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make codeblocks hidden by default
  document.writeln( "<style type=\"text/css\">div.method-source-code { display: none }</style>" )
  
  // ]]>
  </script>

</head>
<body>



    <div id="classHeader">
        <table class="header-table">
        <tr class="top-aligned-row">
          <td><strong>Module</strong></td>
          <td class="class-name-in-header">Globalize::DbTranslate::ClassMethods</td>
        </tr>
        <tr class="top-aligned-row">
            <td><strong>In:</strong></td>
            <td>
                <a href="../../../files/vendor/plugins/globalize/lib/globalize/localization/db_translate_rb.html">
                vendor/plugins/globalize/lib/globalize/localization/db_translate.rb
                </a>
        <br />
            </td>
        </tr>

        </table>
    </div>
  <!-- banner header -->

  <div id="bodyContent">



  <div id="contextContent">



   </div>

    <div id="method-list">
      <h3 class="section-bar">Methods</h3>

      <div class="name-list">
      <a href="#M000012">translate_external</a>&nbsp;&nbsp;
      <a href="#M000011">translate_internal</a>&nbsp;&nbsp;
      <a href="#M000009">translates</a>&nbsp;&nbsp;
      <a href="#M000010">translates_preload</a>&nbsp;&nbsp;
      </div>
    </div>

  </div>


    <!-- if includes -->

    <div id="section">





    <div id="attribute-list">
      <h3 class="section-bar">Attributes</h3>

      <div class="name-list">
        <table>
        <tr class="top-aligned-row context-row">
          <td class="context-item-name">keep_translations_in_model</td>
          <td class="context-item-value">&nbsp;[RW]&nbsp;</td>
          <td class="context-item-desc"></td>
        </tr>
        </table>
      </div>
    </div>
      


    <!-- if method_list -->
    <div id="methods">
      <h3 class="section-bar">Public Instance methods</h3>

      <div id="method-M000009" class="method-detail">
        <a name="M000009"></a>

        <div class="method-heading">
          <a href="#M000009" class="method-signature">
          <span class="method-name">translates</span><span class="method-args">(*facets)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Specifies fields that can be translated. These are normal ActiveRecord
fields, with corresponding database columns. All the translation stuff is
done behind the scenes.
</p>
<p>
This method takes an array of symbols which are the model attributes to be
localized.
</p>
<h3>Example:</h3>
<pre>
  #### In your model:

  class Product &lt; ActiveRecord::Base
    translates :name, :description
  end

  #### In environment.rb:

  Locale.set_base_language(&quot;en_US&quot;)

  #### In your controller:

  Locale.set(&quot;en_US&quot;)
  product.name -&gt; guitar

  Locale.set(&quot;es_ES&quot;)
  product.name -&gt; guitarra
</pre>
<p>
The last entry of the array may be an options hash e.g.
</p>
<pre>
  translates :name, :description, {:some_option =&gt; true}
</pre>
<p>
The available options are described below:
</p>
<h4>Option for Bidrectional text (bidi)</h4>
<p>
Globalize fully supports Bidirectional text. By default all attributes that
have been passed to &#8216;<a
href="ClassMethods.html#M000009">translates</a>&#8217; will have bidi
active.
</p>
<p>
If for some reason, you wish do disactivate bidi for a particular attribute
then you may specify this in the options hash. e.g.
</p>
<pre>
  translates :name, :description, {:name =&gt; {:bidi_embed =&gt; false}}
</pre>
<p>
In this example bidi will be active for the &#8216;description&#8217;
attribute but not for the &#8216;name&#8217; attribute.
</p>
<p>
With &#8216;bidi_embed&#8217; active the direction of the string is
determined in the following manner:
</p>
<ul>
<li>If an attribute has no translation for the current locale then the

</li>
</ul>
<p>
direction will be that of the base locale.
</p>
<ul>
<li>If an attribute has a translation for the currently active locale then

</li>
</ul>
<p>
the direction of it&#8216;s value will be that of the active locale.
</p>
<p>
Note: This feature is valid for both of the currently supported storage
mechanisms
</p>
<h2>Storage Mechanisms</h2>
<p>
Globalize now supports two methods of storing model translations:
</p>
<ul>
<li>The original globalize mechanism shadows the model&#8216;s attributes by
translations in a special translation table

</li>
<li>A newer alternative approach is to store the translations directly within
the models own table by duplicating the columns and using suffixes to
identify the locale.

</li>
</ul>
<p>
Both approaches have their advantages and limitations.
</p>
<p>
By default globalize will use the external table to store translations so
you don&#8216;t have to do anything special.
</p>
<p>
To set the other storage mechanism you have two options.
</p>
<ol>
<li>You can use an application-wide setting which will apply to all models by
setting the following in your environment.rb:

<pre>
  Globalize::DbTranslate.keep_translations_in_model = true
</pre>
</li>
<li>The following example shows how you can override this global setting

</li>
</ol>
<p>
for a particular model:
</p>
<pre>
    class Product &lt; ActiveRecord::Base
      self.keep_translations_in_model = true
      translates :name, :description, :specs
    end
</pre>
<h3>The External Table Storage Mechanism</h3>
<p>
The standard ActiveRecord <tt>find</tt> method has been tweaked to work
with Globalize. Use it in the exact same way you would the regular find,
except for the following provisos:
</p>
<ol>
<li>At this point, it will not work with the <tt>:include</tt> option&#8230;

</li>
<li>However, there is a replacement: <tt>:include_translated</tt>, which is
described below.

</li>
<li>The <tt>:select</tt> option is prohibited.

</li>
</ol>
<p>
<tt>find</tt> returns the retreived models, with all translated fields
correctly loaded, depending on the active language.
</p>
<p>
<tt>:include_translated</tt> works as follows: any model specified in the
<tt>:include_translated</tt> option will be eagerly loaded and added to the
current model as attributes, prefixed with the name of the associated
model. This is often referred to as <em>piggybacking</em>.
</p>
<h3>Example:</h3>
<pre>
  class Product &lt; ActiveRecord::Base
    belongs_to :manufacturer
    belongs_to :category
  end

  class Category &lt; ActiveRecord::Base
    has_many :products
    translates :name
  end

  prods = Product.find(:all, :include_translated =&gt; [ :manufacturer, :category ])
  prods.first.category_name -&gt; &quot;batedeira&quot;
</pre>
<p>
With this option, for every locale change you need to reload your model
instance.
</p>
<h3>The Same Table As Model Storage Mechanism</h3>
<p>
Your model&#8216;s fields, with their corresponding database columns, need
to have a duplicate column that is named with the locale language code as a
suffix.
</p>
<p>
i.e. Apart from the original field&#8216;s column there should be a column
for each locale that is to be supported.
</p>
<h3>Example:</h3>
<pre>
 #### In your model (assuming Globalize::DbTranslate.keep_translations_in_model is true):

 class Product &lt; ActiveRecord::Base
   translates :name, :description
 end

 #### In your schema:

 (Assuming english is the base locale, and we want to support spanish)

 create_table :products do |t|
   t.column :id, :integer
   t.column :name, :string
   t.column :name_es, :string
   t.column :description, :string
   t.column :description_es, :string
   ...

 end
</pre>
<h4>Advantages</h4>
<ul>
<li>This method avoids any extra joins (and thus the limitations to
ActiveRecord::Base#find that apply when using the default mechanism)

</li>
<li>This also means that you have all the localized versions of your model
instance&#8216;s data in one query.

</li>
<li>Changing locale doesn&#8216;t necesitate a reload of the model object in
order to access the localized data for the new locale.

</li>
</ul>
<h4>Disadvantages</h4>
<ul>
<li>Having to maintain all those extra columns may prove to be a maintenance
problem but by using ActiveRecord migrations this should be painless.

</li>
</ul>
<h3>Example usage:</h3>
<pre>
  Locale.set_base_language('en-US')
  Locale.set('en-US')

  #writes to 'name', 'description' columns
  product = Product.create(:name =&gt; 'boots', :description =&gt; 'shiny red wellies')

  puts product.name #Accesses name column (english)
  &gt; 'boots'

  Locale.set('es-ES')
  product.name = 'botas'
  product.save
  puts product.name #Accesses name_es column (spanish),
  &gt; 'botas'

  puts product._name #Accesses original 'name' column
  &gt; 'boots'

  Locale.set('en-US')
  puts product.name #Accesses name column (english)
  &gt; 'boots'
</pre>
<p>
You can create any &#8216;find&#8217; query you want without limitation.
</p>
<p>
A further feature of this mechanism is that the ActiveRecord dynamic
attribute finder mechanism has been overriden to automatically use the
right field for the active locale:
</p>
<pre>
  Locale.set('es-ES')
  product = Product.find_by_name('botas')
  puts product.name
  &gt; 'botas'

  Locale.set('en-US')
  product = Product.find_by_name('boots')
  puts product.name
  &gt; 'boots'

  Locale.set('es-ES')
  puts product.name
  &gt; 'botas'
</pre>
<p>
Use #{facet}_is_base? to check if a translation exists.
</p>
<pre>
  Locale.set('en-US')
  product = Product.create(:name =&gt; 'shoes')

  Locale.set('es-ES')
  product.name_is_base?
  &gt; true

  product.name = 'zapatos'
  product.save
  product.name_is_base?
  &gt; false
</pre>
<p>
Use MyModel.localized_facet(facet) class method to return the correct
localized column name of the current locale. Useful for custom ActiveRecord
find queries.
</p>
<p>
e.g.
</p>
<pre>
  Product.find(:all , :conditions = [&quot;#{Product.localized_facet(:name)} = ?&quot;, name])
</pre>
<p>
<b>Note</b>: The column name suffix that should be used to name the
localized columns (in example Spanish) is that returned by:
</p>
<pre>
  Locale.new('es-ES').language.code (For this example)
</pre>
<h4>Further Options</h4>
<p>
When using this mechanism the following option is available:
</p>
<pre>
  :base_as_default

  e.g.
    class Product
      translates :name, :base_as_default =&gt; true
    end
</pre>
<p>
Set to true (default is false), when you switch to a non-base locale,
localized attributes will return the base locale&#8216;s value rather than
nil if no translation exists for that attribute.
</p>
<pre>
  e.g.

    product = Product.new

    Locale.set(&quot;en_US&quot;)
    product.name = guitar

    Locale.set(&quot;es_ES&quot;)

    #With :base_as_default =&gt; true
    product.name #=&gt; guitar

    #With :base_as_default =&gt; false
    product.name #=&gt; nil

  Then:

    product.name = guitarra

    Locale.set(&quot;en_US&quot;)
    product.name #=&gt; guitar

    Locale.set(&quot;es_ES&quot;)
    product.name #=&gt; guitarra
</pre>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000009-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000009-source">
<pre>
     <span class="ruby-comment cmt"># File vendor/plugins/globalize/lib/globalize/localization/db_translate.rb, line 320</span>
320:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">translates</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">facets</span>)
321:         <span class="ruby-comment cmt"># parse out options hash</span>
322:         <span class="ruby-identifier">options</span> = <span class="ruby-identifier">facets</span>.<span class="ruby-identifier">pop</span> <span class="ruby-keyword kw">if</span> <span class="ruby-identifier">facets</span>.<span class="ruby-identifier">last</span>.<span class="ruby-identifier">kind_of?</span> <span class="ruby-constant">Hash</span>
323:         <span class="ruby-identifier">options</span> <span class="ruby-operator">||=</span> {}
324:         <span class="ruby-identifier">options</span>.<span class="ruby-identifier">reverse_merge!</span>({<span class="ruby-identifier">:base_as_default</span> =<span class="ruby-operator">&gt;</span> <span class="ruby-keyword kw">false</span>})
325: 
326:         <span class="ruby-identifier">keep_translations_internally</span> = <span class="ruby-keyword kw">true</span>
327:         <span class="ruby-keyword kw">if</span> <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">keep_translations_in_model</span>.<span class="ruby-identifier">nil?</span>
328:           <span class="ruby-identifier">keep_translations_internally</span> = <span class="ruby-operator">::</span><span class="ruby-constant">Globalize</span><span class="ruby-operator">::</span><span class="ruby-constant">DbTranslate</span>.<span class="ruby-identifier">keep_translations_in_model</span>
329:         <span class="ruby-keyword kw">else</span>
330:           <span class="ruby-identifier">keep_translations_internally</span> = <span class="ruby-keyword kw">self</span>.<span class="ruby-identifier">keep_translations_in_model</span>
331:         <span class="ruby-keyword kw">end</span>
332: 
333:         <span class="ruby-identifier">keep_translations_internally</span> <span class="ruby-value">? </span><span class="ruby-identifier">translate_internal</span>(<span class="ruby-identifier">facets</span>, <span class="ruby-identifier">options</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">translate_external</span>(<span class="ruby-identifier">facets</span>, <span class="ruby-identifier">options</span>)
334:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000010" class="method-detail">
        <a name="M000010"></a>

        <div class="method-heading">
          <a href="#M000010" class="method-signature">
          <span class="method-name">translates_preload</span><span class="method-args">(*facets)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Optionally specifies translated fields to be preloaded on <tt>find</tt>.
For instance, in a product catalog, you may want to do a <tt>find</tt> of
the first 10 products:
</p>
<pre>
  Product.find(:all, :limit =&gt; 10, :order =&gt; &quot;name&quot;)
</pre>
<p>
But you wouldn&#8216;t want to load the complete descriptions and specs of
all the products, just the names and summaries. So you&#8216;d specify:
</p>
<pre>
  class Product &lt; ActiveRecord::Base
    translates :name, :summary, :description, :specs
    translates_preload :name, :summary
    ...
  end
</pre>
<p>
By default (if no <a
href="ClassMethods.html#M000010">translates_preload</a> is specified),
Globalize will preload the first field given to <tt><a
href="ClassMethods.html#M000009">translates</a></tt>. It will also fully
load on a <tt>find(:first)</tt> or when <tt>:translate_all =&gt; true</tt>
is given as a find option.
</p>
<p>
# Note: <em>Use when Globalize::DbTranslate.keep_translations_in_model is
false</em>
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000010-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000010-source">
<pre>
     <span class="ruby-comment cmt"># File vendor/plugins/globalize/lib/globalize/localization/db_translate.rb, line 357</span>
357:       <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">translates_preload</span>(<span class="ruby-operator">*</span><span class="ruby-identifier">facets</span>)
358:         <span class="ruby-identifier">module_eval</span> <span class="ruby-value str">&quot;@@preload_facets = facets\n&quot;</span>
359:       <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <h3 class="section-bar">Protected Instance methods</h3>

      <div id="method-M000012" class="method-detail">
        <a name="M000012"></a>

        <div class="method-heading">
          <a href="#M000012" class="method-signature">
          <span class="method-name">translate_external</span><span class="method-args">(facets, options)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Default Globalize translations storage mechanism <em>i.e.
Globalize::DbTranslate.keep_translations_in_model is false</em>
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000012-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000012-source">
<pre>
     <span class="ruby-comment cmt"># File vendor/plugins/globalize/lib/globalize/localization/db_translate.rb, line 528</span>
528:         <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">translate_external</span>(<span class="ruby-identifier">facets</span>, <span class="ruby-identifier">options</span>)
529:           <span class="ruby-identifier">facets_string</span> = <span class="ruby-value str">&quot;[&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">facets</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">facet</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;:#{facet}&quot;</span>}.<span class="ruby-identifier">join</span>(<span class="ruby-value str">&quot;, &quot;</span>) <span class="ruby-operator">+</span> <span class="ruby-value str">&quot;]&quot;</span>
530:           <span class="ruby-identifier">class_eval</span> <span class="ruby-value str">&quot;@@facet_options = {}\nattr_writer :fully_loaded\ndef fully_loaded?; @fully_loaded; end\n@@globalize_facets = \#{facets_string}\n@@preload_facets ||= @@globalize_facets\nclass &lt;&lt; self\n\ndef sqlite?; defined?(ActiveRecord::ConnectionAdapters::SQLiteAdapter) and connection.kind_of?(ActiveRecord::ConnectionAdapters::SQLiteAdapter); end\n\ndef globalize_facets\n@@globalize_facets\nend\n\ndef globalize_facets_hash\n@@globalize_facets_hash ||= globalize_facets.inject({}) {|hash, facet|\nhash[facet.to_s] = true; hash\n}\nend\n\ndef untranslated_fields\n@@untranslated_fields ||=\ncolumn_names.map {|cn| cn.intern } - globalize_facets\nend\n\ndef preload_facets; @@preload_facets; end\ndef postload_facets\n@@postload_facets ||= @@globalize_facets - @@preload_facets\nend\nalias_method :globalize_old_find_every, :find_every unless\nrespond_to? :globalize_old_find_every\nend\nalias_method :globalize_old_reload,   :reload\nalias_method :globalize_old_destroy,  :destroy\nalias_method :globalize_old_create_or_update, :create_or_update\nalias_method :globalize_old_update, :update\n\ninclude Globalize::DbTranslate::TranslateObjectMethods\nextend  Globalize::DbTranslate::TranslateClassMethods\n\n&quot;</span>
531: 
532:           <span class="ruby-identifier">facets</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">facet</span><span class="ruby-operator">|</span>
533:             <span class="ruby-identifier">bidi</span> = (<span class="ruby-operator">!</span>(<span class="ruby-identifier">options</span>[<span class="ruby-identifier">facet</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">options</span>[<span class="ruby-identifier">facet</span>][<span class="ruby-identifier">:bidi_embed</span>])).<span class="ruby-identifier">to_s</span>
534:             <span class="ruby-identifier">class_eval</span> <span class="ruby-value str">&quot;@@facet_options[:\#{facet}] ||= {}\n@@facet_options[:\#{facet}][:bidi] = \#{bidi}\n\ndef \#{facet}\nif not_original_language\nraise WrongLanguageError.new(@original_language, Locale.language)\nend\nload_other_translations if\n!fully_loaded? &amp;&amp; !self.class.preload_facets.include?(:\#{facet})\nresult = read_attribute(:\#{facet})\nreturn nil if result.nil?\nresult.direction = \#{facet}_is_base? ?\n(Locale.base_language ? Locale.base_language.direction : nil) :\n(@original_language ? @original_language.direction : nil)\n\n# insert bidi embedding characters, if necessary\nif @@facet_options[:\#{facet}][:bidi] &amp;&amp;\nLocale.language &amp;&amp; Locale.language.direction &amp;&amp; result.direction\nif Locale.language.direction == 'ltr' &amp;&amp; result.direction == 'rtl'\nbidi_str = \&quot;\\xe2\\x80\\xab\&quot; + result + \&quot;\\xe2\\x80\\xac\&quot;\nbidi_str.direction = result.direction\nreturn bidi_str\nelsif Locale.language.direction == 'rtl' &amp;&amp; result.direction == 'ltr'\nbidi_str = \&quot;\\xe2\\x80\\xaa\&quot; + result + \&quot;\\xe2\\x80\\xac\&quot;\nbidi_str.direction = result.direction\nreturn bidi_str\nend\nend\n\nreturn result\nend\n\ndef \#{facet}=(arg)\nraise WrongLanguageError.new(@original_language, Locale.language) if\nnot_original_language\nwrite_attribute(:\#{facet}, arg)\nend\n\ndef \#{facet}_is_base?\nself['\#{facet}_not_base'].nil?\nend\n&quot;</span>
535:           <span class="ruby-keyword kw">end</span>
536:         <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>

      <div id="method-M000011" class="method-detail">
        <a name="M000011"></a>

        <div class="method-heading">
          <a href="#M000011" class="method-signature">
          <span class="method-name">translate_internal</span><span class="method-args">(facets, options)</span>
          </a>
        </div>
      
        <div class="method-description">
          <p>
Alternative storage mechanism storing the translations in the models own
tables.
</p>
<p>
<em>i.e. Globalize::DbTranslate.keep_translations_in_model is true</em>
</p>
          <p><a class="source-toggle" href="#"
            onclick="toggleCode('M000011-source');return false;">[Source]</a></p>
          <div class="method-source-code" id="M000011-source">
<pre>
     <span class="ruby-comment cmt"># File vendor/plugins/globalize/lib/globalize/localization/db_translate.rb, line 370</span>
370:         <span class="ruby-keyword kw">def</span> <span class="ruby-identifier">translate_internal</span>(<span class="ruby-identifier">facets</span>, <span class="ruby-identifier">options</span>)
371:           <span class="ruby-identifier">facets_string</span> = <span class="ruby-value str">&quot;[&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">facets</span>.<span class="ruby-identifier">map</span> {<span class="ruby-operator">|</span><span class="ruby-identifier">facet</span><span class="ruby-operator">|</span> <span class="ruby-node">&quot;:#{facet}&quot;</span>}.<span class="ruby-identifier">join</span>(<span class="ruby-value str">&quot;, &quot;</span>) <span class="ruby-operator">+</span> <span class="ruby-value str">&quot;]&quot;</span>
372:           <span class="ruby-identifier">class_eval</span> <span class="ruby-node">%{
373:             @@facet_options = {}
374:             @@globalize_facets = #{facets_string}
375: 
376:             class &lt;&lt; self
377: 
378:               def globalize_facets
379:                 @@globalize_facets
380:               end
381: 
382: 
383:               #Returns the localized column name of the supplied attribute for the
384:               #current locale
385:               #
386:               #Useful when you have to build up sql by hand or for AR::Base::find conditions
387:               #
388:               #  e.g. Product.find(:all , :conditions = [&quot;\#{Product.localized_facet(:name)} = ?&quot;, name])
389:               #
390:               # Note: &lt;i&gt;Used when Globalize::DbTranslate.keep_translations_in_model is true&lt;/i&gt;
391:               def localized_facet(facet)
392:                 unless Locale.base?
393:                   &quot;\#{facet}_\#{Locale.language.code}&quot;
394:                 else
395:                   facet.to_s
396:                 end
397:               end
398: 
399:               alias_method :globalize_old_method_missing, :method_missing unless
400:                 respond_to? :globalize_old_method_missing
401:             end
402: 
403:             def globalize_facets_hash
404:               @@globalize_facets_hash ||= globalize_facets.inject({}) {|hash, facet|
405:                 hash[facet.to_s] = true; hash
406:               }
407:             end
408: 
409:             def non_localized_fields
410:               @@non_localized_fields ||=
411:                 column_names.map {|cn| cn.intern } - globalize_facets
412:             end
413: 
414:             #Is field translated?
415:             #Returns true if translated
416:             #Warning! Depends on Locale.switch_locale
417:             def translated?(facet, locale_code = nil)
418:               localized_method = &quot;\#{facet}_\#{Locale.language.code}&quot;
419: 
420:               Locale.switch_locale(locale_code) do
421:                 localized_method = &quot;\#{facet}_\#{Locale.language.code}&quot;
422:               end if locale_code
423: 
424:               value = send(localized_method.to_sym) if respond_to?(localized_method.to_sym)
425:               return !value.nil?
426:             end
427: 
428:             extend  Globalize::DbTranslate::InternalStorageClassMethods
429:           }</span>
430: 
431:           <span class="ruby-identifier">facets</span>.<span class="ruby-identifier">each</span> <span class="ruby-keyword kw">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">facet</span><span class="ruby-operator">|</span>
432:             <span class="ruby-identifier">bidi</span> = (<span class="ruby-operator">!</span>(<span class="ruby-identifier">options</span>[<span class="ruby-identifier">facet</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">options</span>[<span class="ruby-identifier">facet</span>][<span class="ruby-identifier">:bidi_embed</span>])).<span class="ruby-identifier">to_s</span>
433:             <span class="ruby-identifier">class_eval</span> <span class="ruby-node">%{
434: 
435:               #Handle facet-specific options (.e.g a bidirectional setting)
436:               @@facet_options[:#{facet}] ||= {}
437:               @@facet_options[:#{facet}][:bidi] = #{bidi}
438: 
439:               #Accessor that proxies to the right accessor for the current locale
440:               def #{facet}
441:                 value = nil
442:                 unless Locale.base?
443:                   localized_method = &quot;#{facet}_\#{Locale.language.code}&quot;
444:                   value = send(localized_method.to_sym) if respond_to?(localized_method.to_sym)
445:                   value = value ? value : read_attribute(:#{facet}) if #{options[:base_as_default]}
446:                 else
447:                   value = read_attribute(:#{facet})
448:                 end
449:                 value.nil? ? nil : add_bidi(value, :#{facet})
450:               end
451: 
452:               #Accessor before typecasting that proxies to the right accessor for the current locale
453:               def #{facet}_before_type_cast
454:                 unless Locale.base?
455:                   localized_method = &quot;#{facet}_\#{Locale.language.code}_before_type_cast&quot;
456:                   value = send(localized_method.to_sym) if respond_to?(localized_method.to_sym)
457:                   value = value ? value : read_attribute_before_type_cast('#{facet}') if #{options[:base_as_default]}
458:                   return value
459:                 else
460:                   value = read_attribute_before_type_cast('#{facet}')
461:                 end
462:                 value.nil? ? nil : add_bidi(value, :#{facet})
463:               end
464: 
465:               #Write to appropriate localized attribute
466:               def #{facet}=(value)
467:                 unless Locale.base?
468:                   localized_method = &quot;#{facet}_\#{Locale.language.code}&quot;
469:                   write_attribute(localized_method.to_sym, value) if respond_to?(localized_method.to_sym)
470:                 else
471:                   write_attribute(:#{facet}, value)
472:                 end
473:               end
474: 
475:               #Is field translated?
476:               #Returns true if untranslated
477:               def #{facet}_is_base?
478:                 localized_method = &quot;#{facet}_\#{Locale.language.code}&quot;
479:                 value = send(localized_method.to_sym) if respond_to?(localized_method.to_sym)
480:                 return value.nil?
481:               end
482: 
483:               #Read base language attribute directly
484:               def _#{facet}
485:                 value = read_attribute(:#{facet})
486:                 value.nil? ? nil : add_bidi(value, :#{facet})
487:               end
488: 
489:               #Read base language attribute directly without typecasting
490:               def _#{facet}_before_type_cast
491:                 read_attribute_before_type_cast('#{facet}')
492:               end
493: 
494:               #Write base language attribute directly
495:               def _#{facet}=(value)
496:                 write_attribute(:#{facet}, value)
497:               end
498: 
499:               def add_bidi(value, facet)
500:                 return value unless Locale.active?
501:                 value.direction = self.send(&quot;\#{facet}_is_base?&quot;) ?
502:                   (Locale.base_language ? Locale.base_language.direction : nil) :
503:                   (Locale.active ? Locale.language.direction : nil)
504: 
505:                   # insert bidi embedding characters, if necessary
506:                   if @@facet_options[facet][:bidi] &amp;&amp;
507:                       Locale.language &amp;&amp; Locale.language.direction &amp;&amp; value.direction
508:                     if Locale.language.direction == 'ltr' &amp;&amp; value.direction == 'rtl'
509:                       bidi_str = &quot;\xe2\x80\xab&quot; + value + &quot;\xe2\x80\xac&quot;
510:                       bidi_str.direction = value.direction
511:                       return bidi_str
512:                     elsif Locale.language.direction == 'rtl' &amp;&amp; value.direction == 'ltr'
513:                       bidi_str = &quot;\xe2\x80\xaa&quot; + value + &quot;\xe2\x80\xac&quot;
514:                       bidi_str.direction = value.direction
515:                       return bidi_str
516:                     end
517:                   end
518:                   return value
519:               end
520: 
521:               protected :add_bidi
522:             }</span>
523:           <span class="ruby-keyword kw">end</span>
524:         <span class="ruby-keyword kw">end</span>
</pre>
          </div>
        </div>
      </div>


    </div>


  </div>


<div id="validator-badges">
  <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
</div>

</body>
</html>